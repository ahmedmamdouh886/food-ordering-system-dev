package com.food.ordering.system.order.service.domain.entity;

import com.food.ordering.system.domain.entity.BaseEntity;
import com.food.ordering.system.domain.valueobject.Money;
import com.food.ordering.system.domain.valueobject.OrderId;
import com.food.ordering.system.order.service.domain.valueobject.OrderItemId;



/*
Since this module is the core-domain-module, I don't want to pollute this with any dependency,
and want to keep my entities and value objects independent even from any framework or library.
So instead of adding Lombok dependency, which has annotations to create the Builder pattern,
I decided to create it using Intellij plugins.
Also, with this way, we will see the constructor and Builder code directly,
it is not hidden as in the Lombok autogenerated code, and if I want to add any validation during the business object creations, I can do that here.
In some other modules, like in the infrastructure modules, I will still use Lombok to prevent Boilerplates Java codes.
However, for core logic, I don't prefer that.
*/
public class OrderItem extends BaseEntity<OrderItemId> {
    // I don't make this field final because these fields will be updated later during business logic.
    private OrderId orderId;
    private final Product product;
    private final int quantity;
    private final Money price;
    // quantity multiplied by price must be equal to subTotal.
    private final Money subTotal;

    private OrderItem(Builder builder) {
        super.setId(builder.orderItemId);
        product = builder.product;
        quantity = builder.quantity;
        price = builder.price;
        subTotal = builder.subTotal;
    }

    public static Builder builder() {
        return new Builder();
    }

    public OrderId getOrderId() {
        return orderId;
    }

    public Product getProduct() {
        return product;
    }

    public int getQuantity() {
        return quantity;
    }

    public Money getPrice() {
        return price;
    }

    public Money getSubTotal() {
        return subTotal;
    }

    // Actually, I can make this initialize order item method "package-private" in the order item class,
    // because I will not reach it outside the package.
    // It should only be called from order entity, so I remove the public access here.
    // package-private meaning.
    // When no access modifier is specified, Java uses a default access level, often called package-private.
    // This means the member is accessible only within classes in the same package.
    // It is less restrictive than private but more restrictive than protected and public.
    void initializeOrderItem(OrderId orderId, OrderItemId orderItemId) {
        this.orderId = orderId;
        super.setId(orderItemId);
    }

    boolean isPriceValid() {
        return price.isGreaterThanZero() &&
               price.equals(product.getPrice()) &&
               price.multiply(quantity).equals(subTotal);
    }

    public static final class Builder {
        private OrderItemId orderItemId;
        private Product product;
        private int quantity;
        private Money price;
        private Money subTotal;

        private Builder() {
        }

        public Builder orderItemId(OrderItemId val) {
            orderItemId = val;
            return this;
        }

        public Builder product(Product val) {
            product = val;
            return this;
        }

        public Builder quantity(int val) {
            quantity = val;
            return this;
        }

        public Builder price(Money val) {
            price = val;
            return this;
        }

        public Builder subTotal(Money val) {
            subTotal = val;
            return this;
        }

        public OrderItem build() {
            return new OrderItem(this);
        }
    }
}
